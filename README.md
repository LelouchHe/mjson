
使用了很长时间的json作为通信协议,觉得可以尝试编写json的解析库,相信是个不错的练习

## 总的要求:
* 内存消耗一定要小
* 速度要够快
* 提供的api要方便使用
* 使用纯C來完成(锻炼自己啦)

目前还没有什么好的思路,暂时把api补全了

## 实现的一点思路
* 不得不解析时再解析.我自己使用json的经验是,很多时候只使用了json的一小部分内容,其他的内容其实大可不必解析,以节约时间和内存消耗
* 共享不可变的原生字符串和COW.这样就不需要每个节点都保存完整的字符串.可能需要带有引用计数的字符串来保存
* 内存的分配有root连接起来,最后统一释放.使用过程中,除了root之外,并不需要用户释放其他节点(当然,除非又new/copy了一个json).想过把json也做成引用计数,但这样使用起来难度过大,故放弃
* iterator应该还是要暴露结构的,否则很难做到局部变量,保持使用习惯

## 关于COW

写的时候重新申请内存放置新的内容,那么什么时候回收呢?当我们需要mj_write或者mj_buf_size時,往往需要遍历所有已经生成的json串:如果被修改过,肯定得重新生成字符串格式,如果没有,就直接返回保存的原始字符串.重新生成之后,是否需要再把节点下的所有字符串拼接起来呢?

我觉得是有必要的,因为2个调用,最后都是要生成字符串的,这样更加节约内存.我们可以保留已经解析成功的json不动,仅仅把字符串表示归一一下,这样也不会影响以后解析的速度.

唯一的缺点是,可能会频繁的申请/释放内存,这个感觉暂时可以接受,实在不行,可以改变共享字符串的实现,底层使用ring來保存常见字符串即可,而依赖于其上的json处理不变

## map的实现

现在实现了一个小型的hashmap,用以保存json中的object对象的kv.此处,kv的生存期由调用方保证,k使用了双hash來简化判断

此处,k比较微妙.最好的方式是k从原生字符串來,因为k基本不会变化,所以是常量.但这样的话,k就不是单纯的char *,而是复杂的引用计数字符串了.

所幸,原有的逻辑应该不会太大变动,等实现了引用计数字符串,再來修改map

## ref_str的实现

做这个很纠结,因为感觉不论怎样定义接口,使用起来总是没有原生的**char**來的舒坦,不过聊胜于无,姑且先利用这个版本的ref_str吧

这个版本的ref_str倾向于使用局部变量的形式嵌套进其他结构体或函数体内.因为如果以指针形式引入,势必会带来生存期的问题,谁來管理这个指针,而且这里又需要动态分配内存了(其实一样,区别在于调用1次malloc或者2次)

局部变量的问题就是需要暴露很多内部信息,这里暴露的begin/end和内部的指针

我觉得还是改回来吧

## 再论COW

随着实现的深入,觉得COW可能不是很好的方式.比如每次as_string时,虽然我们不需要更改该json结构,但是呢,返回的char*指向什么位置呢?我们最好可以返回的是常规的字符串(以'\0'结尾),所以ref_str可能不是很好的选择,所以此时应该也需要新建一个ref_str保留这个字符串

所以看来,不仅写时需要新建,在提取字符串时同样需要.

在返回其他类型时则不需要类似的,因为字符串是最常见的转型,而且人们对字符串转型应该是可以预期的,而其他的不然

## json结构

基础的json大致需要以下几个字段:
* type: 类型,共8个,用3bit即可
* is_root: 是否是根节点.当删除节点時,本节点是否一同释放,是个问题,对于根节点,是可以的,但子节点,是不能删除的(否则其父节点指针就over了),所以,对于子节点,应该把它的子节点全部删除,但保留本身(设置为NULL节点即可)
* is_dirty: 是否被改写过,改写之前需要确认是否相同再修改.主要用于递归write時
* is_str: text是否为char*.当as_string時,肯定需要一个'\0'结尾的字符串,这个的生存期肯定也得受json控制,那么此时就直接复用text.不过这个只针对基础类型(非object和array),因为基础类型的text,即使是ref_str,也不会有人來引用的

以上三个总共占6bit,再剩余2bit备用

## 关于表示

因为要处理删除甚至转型,所以直接操作引用json结构貌似不是很可行(就像mjson一度设计的那样,类似继承的包含结构)

现在的表示就是二级结构,操作引用的是一个类似句柄的东东,里面再指向真正的表示,这样的表达就更加灵活的

添加句柄的好处是增加了一个间接层,很多额外的东西我们可以操作了,比如引用计数,比如统计,再比如我们可以任意赋值,而不用担心指针问题(因为句柄不变,只是指向变了而已).坏处是增加了内存消耗,不过此处额外的只有ref,所以应该问题不大
