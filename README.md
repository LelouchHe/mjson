
## region 你们看不到

这篇文档是开发mjson的思路的汇总,没有做任何整理,基本是按时间顺序來的

所以可以看到我思路确实不大好啊

退散...

使用了很长时间的json作为通信协议,觉得可以尝试编写json的解析库,相信是个不错的练习

## 总的要求:
* 内存消耗一定要小
* 速度要够快
* 提供的api要方便使用
* 使用纯C來完成(锻炼自己啦)

目前还没有什么好的思路,暂时把api补全了

## 实现的一点思路
* 不得不解析时再解析.我自己使用json的经验是,很多时候只使用了json的一小部分内容,其他的内容其实大可不必解析,以节约时间和内存消耗
* 共享不可变的原生字符串和COW.这样就不需要每个节点都保存完整的字符串.可能需要带有引用计数的字符串来保存
* 内存的分配有root连接起来,最后统一释放.使用过程中,除了root之外,并不需要用户释放其他节点(当然,除非又new/copy了一个json).想过把json也做成引用计数,但这样使用起来难度过大,故放弃
* iterator应该还是要暴露结构的,否则很难做到局部变量,保持使用习惯

## 关于COW

写的时候重新申请内存放置新的内容,那么什么时候回收呢?当我们需要mj_write或者mj_buf_size時,往往需要遍历所有已经生成的json串:如果被修改过,肯定得重新生成字符串格式,如果没有,就直接返回保存的原始字符串.重新生成之后,是否需要再把节点下的所有字符串拼接起来呢?

我觉得是有必要的,因为2个调用,最后都是要生成字符串的,这样更加节约内存.我们可以保留已经解析成功的json不动,仅仅把字符串表示归一一下,这样也不会影响以后解析的速度.

唯一的缺点是,可能会频繁的申请/释放内存,这个感觉暂时可以接受,实在不行,可以改变共享字符串的实现,底层使用ring來保存常见字符串即可,而依赖于其上的json处理不变

## map的实现

现在实现了一个小型的hashmap,用以保存json中的object对象的kv.此处,kv的生存期由调用方保证,k使用了双hash來简化判断

此处,k比较微妙.最好的方式是k从原生字符串來,因为k基本不会变化,所以是常量.但这样的话,k就不是单纯的char *,而是复杂的引用计数字符串了.

所幸,原有的逻辑应该不会太大变动,等实现了引用计数字符串,再來修改map

## ref_str的实现

做这个很纠结,因为感觉不论怎样定义接口,使用起来总是没有原生的**char**來的舒坦,不过聊胜于无,姑且先利用这个版本的ref_str吧

这个版本的ref_str倾向于使用局部变量的形式嵌套进其他结构体或函数体内.因为如果以指针形式引入,势必会带来生存期的问题,谁來管理这个指针,而且这里又需要动态分配内存了(其实一样,区别在于调用1次malloc或者2次)

局部变量的问题就是需要暴露很多内部信息,这里暴露的begin/end和内部的指针

我觉得还是改回来吧

## 再论COW

随着实现的深入,觉得COW可能不是很好的方式.比如每次as_string时,虽然我们不需要更改该json结构,但是呢,返回的char*指向什么位置呢?我们最好可以返回的是常规的字符串(以'\0'结尾),所以ref_str可能不是很好的选择,所以此时应该也需要新建一个ref_str保留这个字符串

所以看来,不仅写时需要新建,在提取字符串时同样需要.

在返回其他类型时则不需要类似的,因为字符串是最常见的转型,而且人们对字符串转型应该是可以预期的,而其他的不然

## json结构

基础的json大致需要以下几个字段:
* type: 类型,共8个,用3bit即可
* is_root: 是否是根节点.当删除节点時,本节点是否一同释放,是个问题,对于根节点,是可以的,但子节点,是不能删除的(否则其父节点指针就over了),所以,对于子节点,应该把它的子节点全部删除,但保留本身(设置为NULL节点即可)
* is_dirty: 是否被改写过,改写之前需要确认是否相同再修改.主要用于递归write時
* is_str: text是否为char*.当as_string時,肯定需要一个'\0'结尾的字符串,这个的生存期肯定也得受json控制,那么此时就直接复用text.不过这个只针对基础类型(非object和array),因为基础类型的text,即使是ref_str,也不会有人來引用的

以上三个总共占6bit,再剩余2bit备用

### 更新

既然我们已经采用引用计数了,那么是否还有必要保留is_root呢?

我觉得没有必要了,is_root是一个临时的产物,当引用计数为0时,必然可以删除这个节点的.

引用计数主要不是为了避免内存泄露(引用计数实际比内存更恶心有没有),主要是为了不让在使用json时,发现json底层已经没了,然后就core

所以使用时,首先要增加ref,使用完毕,手动deref,或者加入其他组合类型中,自动deref

## 关于表示

因为要处理删除甚至转型,所以直接操作引用json结构貌似不是很可行(就像mjson一度设计的那样,类似继承的包含结构,其实也是可以的,比如改用union)

现在的表示就是二级结构,操作引用的是一个类似句柄的东东,里面再指向真正的表示,这样的表达就更加灵活的

添加句柄的好处是增加了一个间接层,很多额外的东西我们可以操作了,比如引用计数,比如统计,再比如我们可以任意赋值,而不用担心指针问题(因为句柄不变,只是指向变了而已).坏处是增加了内存消耗,不过此处额外的只有ref,所以应该问题不大

## 字符串表示总结

* bool/null属于静态类型,指向的是全局静态变量,ref_str指向的是const char*(is_str===1)
* int/double/str属于基本类型,不会进行初始化,但as_string时会有默认值(如果为空的话).is_str标识ref_str是否为char*
* object/array属于组合类型,永远使用ref_str(is_str===0)

这样的分类主要是基于后续的使用,一来初始化后没有赋值直接使用本来很少见,所以选择不进行初始化,二来,组合类型的子节点可能复用父节点的ref_str,但基本类型则很少用到了

## 引用计数

以前觉得引用计数很难,实际实现之后发现有那么多的模型需要折衷,越发觉得难了

现在我能想到的有2种基本模型:
* refp -> ref+data: 所有的使用都是基于同一个refp的.这样的优点是不需要每次都动态生成新的refp,缺点就是没有办法阻止我们不停的dec这个refp,只要refp指向还有效,就可以一直错误的dec,直到被销毁.这其实没有什么,关键是没有办法检测到类似的情况
* refpa -> ref+data <- refpb: 每次使用都是新的refp,ref不再是真正使用者,而是refp的数量了(第一种refp不变,ref记录的是真正使用者的数量).这个缺点就是上面那个的优点(动态生成refp),优点就是我们有方法阻止不停的dec了,直接把refp释放掉,如果2次dec,就是AV,直接可能会core

还有个问题是随之而来的,即试图修改refp会带来什么样的后果,比如reset.我们是reset这个refp(比如调整其指向),还是修改data的值.而且使用2种不同的模型,也会带来不同的含义(一个是一变全变,另一个是只有一个变)

### 使用哪种模型和reset语义

在mjson中,我们的目标是尽量做到动态语义.比如mj的类型本来是MJSON_OBJECT,但是我可以直接赋值为array,mj的类型就变成了MJSON_ARRAY

同样有2种模型:
* p -> union: 这样p不需要变动,直接操作union中的值即可,里面可以是类型之类的json结构
* p -> handle -> value: 这样value是独立的value,修改p,实际上是修改handle的指向,并不影响原先的value

union是占空间较大,handle的缺点是handle/value都需要动态生成(union的value本身不需要,只需要赋值即可)

针对mjson,其实二者相差不多,union也就多一个指针大小,而handle也多出指针大小

### 混淆

感觉我在这里混淆了2个概念--引用指针的reset和json的reset.而且json的设计动不动就扯上了refp上.

看来选择太多,让我都不能前进了.好吧,理清思路

